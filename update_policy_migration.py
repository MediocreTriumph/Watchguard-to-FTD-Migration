#!/usr/bin/env python3
"""
Update the policy migration script to use the new service object mappings.
Generates updated service lookup logic using deduplication and WG mapping.
"""

import json
import sys
from typing import Dict, Optional


def load_deduplication_map(filename: str = "port_deduplication_map.json") -> Dict:
    """Load the deduplication map."""
    try:
        with open(filename, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"✗ Error: {filename} not found. Run analyze_fmc_services.py first.")
        sys.exit(1)
    except Exception as e:
        print(f"✗ Error loading {filename}: {e}")
        sys.exit(1)


def load_wg_mapping(filename: str = "wg_to_fmc_mapping.json") -> Dict:
    """Load the WatchGuard to FMC mapping."""
    try:
        with open(filename, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"✗ Error: {filename} not found. Run build_wg_service_groups.py first.")
        sys.exit(1)
    except Exception as e:
        print(f"✗ Error loading {filename}: {e}")
        sys.exit(1)


def generate_lookup_code(dedup_map: Dict, wg_mapping: Dict) -> str:
    """Generate Python code for service lookup function."""
    
    code = '''#!/usr/bin/env python3
"""
Enhanced service lookup for policy migration.
Uses deduplication map and WatchGuard service mappings.
Auto-generated by update_policy_migration.py
"""

import json
from typing import Dict, Optional, List


# Canonical mapping for protocol+port combinations
CANONICAL_MAP = '''
    
    # Build canonical map from dedup data
    canonical_map = {}
    for obj_id, info in dedup_map.get('canonical_map', {}).items():
        key = f"{info['protocol']}_{info['port']}"
        canonical_map[key] = {
            'name': info['canonical_name'],
            'id': info['canonical_id']
        }
    
    code += json.dumps(canonical_map, indent=2)
    code += '\n\n# WatchGuard service name to FMC object mapping\nWG_SERVICE_MAP = '
    code += json.dumps(wg_mapping.get('wg_to_fmc_mapping', {}), indent=2)
    code += '''


def lookup_service_by_name(service_name: str) -> Optional[Dict]:
    """
    Look up a service by WatchGuard name.
    Returns FMC object/group information if found.
    """
    # Normalize name (spaces to underscores)
    normalized_name = service_name.replace(' ', '_')
    
    # Check direct mapping
    if service_name in WG_SERVICE_MAP:
        return WG_SERVICE_MAP[service_name]
    
    if normalized_name in WG_SERVICE_MAP:
        return WG_SERVICE_MAP[normalized_name]
    
    return None


def lookup_service_by_protocol_port(protocol: str, port: str) -> Optional[Dict]:
    """
    Look up a service by protocol and port.
    Returns canonical FMC object if found.
    
    Args:
        protocol: Protocol name (TCP, UDP, etc.)
        port: Port number or range as string
    
    Returns:
        Dict with 'name' and 'id' keys, or None if not found
    """
    key = f"{protocol}_{port}"
    
    if key in CANONICAL_MAP:
        return CANONICAL_MAP[key]
    
    return None


def get_fmc_service_for_migration(wg_service_name: str, protocol: str = None, port: str = None) -> Dict:
    """
    Main function to get FMC service object for policy migration.
    
    Lookup priority:
    1. By WatchGuard service name (returns group if multiple ports, object if single)
    2. By protocol+port (returns canonical object)
    3. Returns error dict if not found
    
    Args:
        wg_service_name: Original WatchGuard service name
        protocol: Optional protocol (TCP/UDP) for fallback lookup
        port: Optional port number for fallback lookup
    
    Returns:
        Dict with FMC object information or error
    """
    result = {
        'wg_name': wg_service_name,
        'found': False,
        'fmc_name': None,
        'fmc_id': None,
        'fmc_type': None,
        'lookup_method': None
    }
    
    # Try lookup by name first
    name_lookup = lookup_service_by_name(wg_service_name)
    if name_lookup:
        result['found'] = True
        result['lookup_method'] = 'by_name'
        
        if name_lookup['type'] == 'group':
            result['fmc_name'] = name_lookup['fmc_group_name']
            result['fmc_id'] = name_lookup['fmc_group_id']
            result['fmc_type'] = 'PortObjectGroup'
        else:
            result['fmc_name'] = name_lookup['fmc_object_name']
            result['fmc_id'] = name_lookup['fmc_object_id']
            result['fmc_type'] = 'ProtocolPortObject'
        
        return result
    
    # Fallback to protocol+port lookup
    if protocol and port:
        port_lookup = lookup_service_by_protocol_port(protocol, port)
        if port_lookup:
            result['found'] = True
            result['lookup_method'] = 'by_protocol_port'
            result['fmc_name'] = port_lookup['name']
            result['fmc_id'] = port_lookup['id']
            result['fmc_type'] = 'ProtocolPortObject'
            return result
    
    # Not found
    result['error'] = f"No FMC mapping found for WatchGuard service '{wg_service_name}'"
    if protocol and port:
        result['error'] += f" (Protocol: {protocol}, Port: {port})"
    
    return result


def batch_lookup_services(wg_services: List[Dict]) -> List[Dict]:
    """
    Batch lookup multiple WatchGuard services.
    
    Args:
        wg_services: List of dicts with 'name', 'protocol', 'port' keys
    
    Returns:
        List of lookup results
    """
    results = []
    
    for service in wg_services:
        name = service.get('name')
        protocol = service.get('protocol')
        port = service.get('port')
        
        result = get_fmc_service_for_migration(name, protocol, port)
        results.append(result)
    
    return results


# Example usage
if __name__ == "__main__":
    # Test lookups
    test_services = [
        {"name": "AWS Workspace", "protocol": "TCP", "port": "443"},
        {"name": "HTTP", "protocol": "TCP", "port": "80"},
        {"name": "HTTPS", "protocol": "TCP", "port": "443"},
    ]
    
    print("Testing service lookups...")
    print("=" * 80)
    
    for service in test_services:
        result = get_fmc_service_for_migration(
            service['name'],
            service['protocol'],
            service['port']
        )
        
        print(f"\\nWatchGuard: {service['name']} ({service['protocol']}/{service['port']})")
        print(f"  Found: {result['found']}")
        print(f"  FMC Name: {result.get('fmc_name', 'N/A')}")
        print(f"  FMC ID: {result.get('fmc_id', 'N/A')}")
        print(f"  FMC Type: {result.get('fmc_type', 'N/A')}")
        print(f"  Lookup Method: {result.get('lookup_method', 'N/A')}")
        if 'error' in result:
            print(f"  Error: {result['error']}")
'''
    
    return code


def main():
    print("=" * 80)
    print("Generating Updated Policy Migration Service Lookup")
    print("=" * 80)
    
    # Load input files
    print("\nLoading input files...")
    dedup_map = load_deduplication_map()
    wg_mapping = load_wg_mapping()
    print("✓ Loaded deduplication map and WG mapping")
    
    # Generate lookup code
    print("\nGenerating service lookup code...")
    lookup_code = generate_lookup_code(dedup_map, wg_mapping)
    
    # Write to file
    output_file = "service_lookup.py"
    with open(output_file, 'w') as f:
        f.write(lookup_code)
    
    print(f"✓ Generated {output_file}")
    
    # Generate integration instructions
    instructions = """
================================================================================
INTEGRATION INSTRUCTIONS
================================================================================

The service_lookup.py module has been generated with the following functions:

1. lookup_service_by_name(service_name)
   - Look up by WatchGuard service name
   - Returns group or object info

2. lookup_service_by_protocol_port(protocol, port)
   - Look up by protocol+port
   - Returns canonical object info

3. get_fmc_service_for_migration(wg_service_name, protocol, port)
   - Main lookup function for policy migration
   - Tries name lookup first, falls back to protocol+port
   - Returns complete FMC object information

4. batch_lookup_services(wg_services)
   - Batch process multiple services at once

USAGE IN YOUR POLICY MIGRATION SCRIPT:
--------------------------------------
from service_lookup import get_fmc_service_for_migration

# When processing a WatchGuard policy rule:
wg_service_name = "AWS Workspace"
wg_protocol = "TCP"
wg_port = "443"

result = get_fmc_service_for_migration(wg_service_name, wg_protocol, wg_port)

if result['found']:
    fmc_object_id = result['fmc_id']
    fmc_object_name = result['fmc_name']
    fmc_object_type = result['fmc_type']  # 'ProtocolPortObject' or 'PortObjectGroup'
    
    # Use this in your FMC API call for the policy rule
    service_reference = {
        'type': fmc_object_type,
        'id': fmc_object_id,
        'name': fmc_object_name
    }
else:
    print(f"Error: {result['error']}")

REPLACE YOUR OLD LOOKUP LOGIC:
-------------------------------
Old code that looked like:
    matching_service = next((s for s in fmc_services if s['port'] == wg_port), None)

New code:
    result = get_fmc_service_for_migration(wg_service_name, wg_protocol, wg_port)
    if result['found']:
        # Use result['fmc_id'] and result['fmc_name']
"""
    
    print(instructions)
    
    # Write instructions to file
    with open("INTEGRATION_INSTRUCTIONS.txt", 'w') as f:
        f.write(instructions)
    
    print("\n✓ Integration instructions written to: INTEGRATION_INSTRUCTIONS.txt")
    print("\nNext steps:")
    print("  1. Review service_lookup.py")
    print("  2. Test the lookup functions with your data")
    print("  3. Integrate into your policy migration script")
    print("  4. Run policy migration with new service mappings")


if __name__ == "__main__":
    main()